#!/usr/bin/env node

/**
 * Comprehensive IDE Integration Test Suite
 * Tests the enhanced implementation and all edge cases
 */

const http = require('http');
const https = require('https');
const { exec } = require('child_process');
const { promisify } = require('util');
const fs = require('fs').promises;
const path = require('path');
const os = require('os');

const execAsync = promisify(exec);

// Test configuration
const TEST_CONFIG = {
  baseUrl: 'http://localhost:3000',
  generationId: `test-${Date.now()}`,
  projectName: 'test-service-integration',
  ides: ['vscode', 'cursor'],
  testData: {
    mockMdContent: `# Test Service

## Overview
This is a test service generated by DevX Platform.

### src/index.ts

\`\`\`typescript
import express from 'express';

const app = express();
const PORT = process.env.PORT || 3000;

app.get('/health', (req, res) => {
  res.json({ status: 'healthy', timestamp: new Date().toISOString() });
});

app.listen(PORT, () => {
  console.log(\`Server running on port \${PORT}\`);
});

export default app;
\`\`\`

### package.json

\`\`\`json
{
  "name": "test-service-integration",
  "version": "1.0.0",
  "description": "Test service for integration testing",
  "main": "dist/index.js",
  "scripts": {
    "dev": "ts-node src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js",
    "test": "jest"
  },
  "dependencies": {
    "express": "^4.18.2"
  },
  "devDependencies": {
    "@types/express": "^4.17.17",
    "@types/node": "^20.0.0",
    "typescript": "^5.0.0",
    "ts-node": "^10.9.1",
    "jest": "^29.5.0"
  }
}
\`\`\`

### Dockerfile

\`\`\`dockerfile
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm install

COPY . .
RUN npm run build

EXPOSE 3000

CMD ["npm", "start"]
\`\`\`

### tests/index.test.ts

\`\`\`typescript
import request from 'supertest';
import app from '../src/index';

describe('Health Check', () => {
  it('should return healthy status', async () => {
    const response = await request(app)
      .get('/health')
      .expect(200);
    
    expect(response.body.status).toBe('healthy');
    expect(response.body.timestamp).toBeDefined();
  });
});
\`\`\`

## Getting Started

1. Install dependencies:
   \`\`\`bash
   npm install
   \`\`\`

2. Start development server:
   \`\`\`bash
   npm run dev
   \`\`\`

3. Run tests:
   \`\`\`bash
   npm test
   \`\`\`
`
  }
};

// Color codes for terminal output
const colors = {
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m',
  reset: '\x1b[0m'
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

// Test results tracker
const testResults = {
  passed: 0,
  failed: 0,
  warnings: 0,
  tests: []
};

function recordTest(name, status, message, severity = 'info') {
  testResults.tests.push({ name, status, message, severity });
  if (status === 'PASS') testResults.passed++;
  else if (status === 'FAIL') testResults.failed++;
  else if (status === 'WARN') testResults.warnings++;
}

// Test 1: Basic endpoint connectivity
async function testEndpointConnectivity() {
  log('\n=== Test 1: Endpoint Connectivity ===', 'blue');
  
  const endpoints = [
    '/api/generate/ide-launch',
    '/api/generate/ide-launch-enhanced',
    '/api/generate/extract-files'
  ];
  
  for (const endpoint of endpoints) {
    try {
      const url = `${TEST_CONFIG.baseUrl}${endpoint}`;
      const response = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          generationId: TEST_CONFIG.generationId,
          ide: 'vscode',
          projectName: TEST_CONFIG.projectName
        })
      });
      
      if (response.status === 405) {
        log(`✅ ${endpoint} - Endpoint exists (405 Method Not Allowed expected for invalid data)`, 'green');
        recordTest(`Connectivity: ${endpoint}`, 'PASS', 'Endpoint accessible');
      } else {
        log(`⚠️ ${endpoint} - Status: ${response.status}`, 'yellow');
        recordTest(`Connectivity: ${endpoint}`, 'WARN', `Unexpected status: ${response.status}`);
      }
    } catch (error) {
      log(`❌ ${endpoint} - Connection failed: ${error.message}`, 'red');
      recordTest(`Connectivity: ${endpoint}`, 'FAIL', `Connection failed: ${error.message}`, 'critical');
    }
  }
}

// Test 2: Enhanced IDE Launch endpoint
async function testEnhancedIDELaunch() {
  log('\n=== Test 2: Enhanced IDE Launch ===', 'blue');
  
  // First, we need to mock the download endpoint
  // Since we're testing locally, we'll test the endpoint logic
  
  for (const ide of TEST_CONFIG.ides) {
    log(`\nTesting ${ide.toUpperCase()} launch...`);
    
    try {
      const response = await fetch(`${TEST_CONFIG.baseUrl}/api/generate/ide-launch-enhanced`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          generationId: TEST_CONFIG.generationId,
          ide,
          projectName: TEST_CONFIG.projectName
        })
      });
      
      const result = await response.json();
      
      if (response.ok) {
        log(`✅ ${ide} - API call successful`, 'green');
        log(`   IDE URL: ${result.ideUrl}`);
        log(`   Local Path: ${result.localPath}`);
        log(`   Files Created: ${result.filesCreated || 'N/A'}`);
        
        // Validate URL format
        const expectedUrlStart = ide === 'vscode' ? 'vscode://file/' : 'cursor://file/';
        if (result.ideUrl && result.ideUrl.startsWith(expectedUrlStart)) {
          log(`✅ ${ide} - URL format correct`, 'green');
          recordTest(`Enhanced Launch: ${ide} URL format`, 'PASS', 'Correct URL scheme');
        } else {
          log(`❌ ${ide} - URL format incorrect: ${result.ideUrl}`, 'red');
          recordTest(`Enhanced Launch: ${ide} URL format`, 'FAIL', 'Incorrect URL scheme', 'high');
        }
        
        recordTest(`Enhanced Launch: ${ide}`, 'PASS', 'API call successful');
      } else {
        log(`❌ ${ide} - API call failed: ${result.error}`, 'red');
        log(`   Details: ${result.details || 'No additional details'}`);
        recordTest(`Enhanced Launch: ${ide}`, 'FAIL', `API call failed: ${result.error}`, 'high');
      }
    } catch (error) {
      log(`❌ ${ide} - Request failed: ${error.message}`, 'red');
      recordTest(`Enhanced Launch: ${ide}`, 'FAIL', `Request failed: ${error.message}`, 'critical');
    }
  }
}

// Test 3: Basic IDE Launch endpoint (fallback)
async function testBasicIDELaunch() {
  log('\n=== Test 3: Basic IDE Launch (Fallback) ===', 'blue');
  
  for (const ide of TEST_CONFIG.ides) {
    log(`\nTesting ${ide.toUpperCase()} basic launch...`);
    
    try {
      const response = await fetch(`${TEST_CONFIG.baseUrl}/api/generate/ide-launch`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          generationId: TEST_CONFIG.generationId,
          ide,
          projectName: TEST_CONFIG.projectName
        })
      });
      
      const result = await response.json();
      
      if (response.ok) {
        log(`✅ ${ide} - Basic API call successful`, 'green');
        log(`   IDE URL: ${result.ideUrl}`);
        log(`   Instructions provided: ${result.instructions ? 'Yes' : 'No'}`);
        
        // Validate URL format for basic endpoint
        const expectedUrlStart = ide === 'vscode' ? 'vscode://file/' : 'cursor://file/';
        if (result.ideUrl && result.ideUrl.startsWith(expectedUrlStart)) {
          log(`✅ ${ide} - Basic URL format correct`, 'green');
          recordTest(`Basic Launch: ${ide} URL format`, 'PASS', 'Correct URL scheme');
        } else {
          log(`❌ ${ide} - Basic URL format incorrect: ${result.ideUrl}`, 'red');
          recordTest(`Basic Launch: ${ide} URL format`, 'FAIL', 'Incorrect URL scheme', 'medium');
        }
        
        recordTest(`Basic Launch: ${ide}`, 'PASS', 'Basic API call successful');
      } else {
        log(`❌ ${ide} - Basic API call failed: ${result.error}`, 'red');
        recordTest(`Basic Launch: ${ide}`, 'FAIL', `Basic API call failed: ${result.error}`, 'medium');
      }
    } catch (error) {
      log(`❌ ${ide} - Basic request failed: ${error.message}`, 'red');
      recordTest(`Basic Launch: ${ide}`, 'FAIL', `Basic request failed: ${error.message}`, 'high');
    }
  }
}

// Test 4: File extraction endpoint
async function testFileExtraction() {
  log('\n=== Test 4: File Extraction ===', 'blue');
  
  try {
    const response = await fetch(`${TEST_CONFIG.baseUrl}/api/generate/extract-files`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        generationId: TEST_CONFIG.generationId,
        projectName: TEST_CONFIG.projectName,
        mdContent: TEST_CONFIG.testData.mockMdContent
      })
    });
    
    const result = await response.json();
    
    if (response.ok) {
      log(`✅ File extraction successful`, 'green');
      log(`   Extract path: ${result.extractPath}`);
      log(`   Files extracted: ${result.filesExtracted}`);
      log(`   Metadata created: ${result.metadata ? 'Yes' : 'No'}`);
      
      // Check if files were actually created
      if (result.extractPath) {
        try {
          const stats = await fs.stat(result.extractPath);
          if (stats.isDirectory()) {
            log(`✅ Project directory created successfully`, 'green');
            
            // List extracted files
            const files = await fs.readdir(result.extractPath, { withFileTypes: true });
            log(`   Files found: ${files.map(f => f.name).join(', ')}`);
            
            recordTest('File Extraction: Directory Creation', 'PASS', 'Project directory created');
            recordTest('File Extraction: Files Created', 'PASS', `${result.filesExtracted} files extracted`);
            
            // Clean up test directory
            await fs.rm(result.extractPath, { recursive: true, force: true });
            log(`   Cleaned up test directory`, 'cyan');
          }
        } catch (dirError) {
          log(`❌ Project directory not accessible: ${dirError.message}`, 'red');
          recordTest('File Extraction: Directory Access', 'FAIL', 'Directory not accessible', 'high');
        }
      }
      
      recordTest('File Extraction: API', 'PASS', 'API call successful');
    } else {
      log(`❌ File extraction failed: ${result.error}`, 'red');
      recordTest('File Extraction: API', 'FAIL', `API call failed: ${result.error}`, 'high');
    }
  } catch (error) {
    log(`❌ File extraction request failed: ${error.message}`, 'red');
    recordTest('File Extraction: API', 'FAIL', `Request failed: ${error.message}`, 'critical');
  }
}

// Test 5: Error handling and edge cases
async function testErrorHandling() {
  log('\n=== Test 5: Error Handling & Edge Cases ===', 'blue');
  
  const errorTests = [
    {
      name: 'Missing IDE parameter',
      body: { generationId: TEST_CONFIG.generationId, projectName: TEST_CONFIG.projectName },
      endpoint: '/api/generate/ide-launch-enhanced'
    },
    {
      name: 'Invalid IDE parameter',
      body: { generationId: TEST_CONFIG.generationId, ide: 'invalid-ide', projectName: TEST_CONFIG.projectName },
      endpoint: '/api/generate/ide-launch-enhanced'
    },
    {
      name: 'Missing generation ID',
      body: { ide: 'vscode', projectName: TEST_CONFIG.projectName },
      endpoint: '/api/generate/ide-launch-enhanced'
    },
    {
      name: 'Empty project name',
      body: { generationId: TEST_CONFIG.generationId, ide: 'vscode', projectName: '' },
      endpoint: '/api/generate/ide-launch-enhanced'
    },
    {
      name: 'Special characters in project name',
      body: { generationId: TEST_CONFIG.generationId, ide: 'vscode', projectName: 'test/project<>name' },
      endpoint: '/api/generate/ide-launch-enhanced'
    },
    {
      name: 'Missing MD content for extraction',
      body: { generationId: TEST_CONFIG.generationId, projectName: TEST_CONFIG.projectName },
      endpoint: '/api/generate/extract-files'
    }
  ];
  
  for (const test of errorTests) {
    log(`\nTesting: ${test.name}`);
    
    try {
      const response = await fetch(`${TEST_CONFIG.baseUrl}${test.endpoint}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(test.body)
      });
      
      const result = await response.json();
      
      if (response.ok) {
        log(`⚠️ ${test.name} - Expected error but got success`, 'yellow');
        recordTest(`Error Handling: ${test.name}`, 'WARN', 'Expected error but got success');
      } else {
        log(`✅ ${test.name} - Properly returned error (${response.status})`, 'green');
        log(`   Error: ${result.error || 'No error message'}`);
        recordTest(`Error Handling: ${test.name}`, 'PASS', 'Properly handled error case');
      }
    } catch (error) {
      log(`❌ ${test.name} - Request failed: ${error.message}`, 'red');
      recordTest(`Error Handling: ${test.name}`, 'FAIL', `Request failed: ${error.message}`, 'medium');
    }
  }
}

// Test 6: IDE installation check
async function testIDEInstallation() {
  log('\n=== Test 6: IDE Installation Check ===', 'blue');
  
  for (const ide of TEST_CONFIG.ides) {
    try {
      // Try to find the IDE in the system PATH
      const command = process.platform === 'win32' ? `where ${ide}` : `which ${ide}`;
      await execAsync(command);
      
      log(`✅ ${ide.toUpperCase()} is installed and in PATH`, 'green');
      recordTest(`IDE Installation: ${ide}`, 'PASS', 'IDE is installed');
      
      // Try to get version
      try {
        const versionCommand = `${ide} --version`;
        const { stdout } = await execAsync(versionCommand);
        log(`   Version: ${stdout.trim()}`, 'cyan');
      } catch (versionError) {
        log(`   Could not determine version`, 'yellow');
      }
      
    } catch (error) {
      log(`⚠️ ${ide.toUpperCase()} is not installed or not in PATH`, 'yellow');
      recordTest(`IDE Installation: ${ide}`, 'WARN', 'IDE not installed or not in PATH');
      
      // Check common installation paths
      const commonPaths = process.platform === 'win32' 
        ? [`C:\\Users\\${os.userInfo().username}\\AppData\\Local\\Programs\\${ide}\\${ide}.exe`]
        : [`/Applications/${ide.charAt(0).toUpperCase() + ide.slice(1)}.app`];
      
      for (const commonPath of commonPaths) {
        try {
          await fs.access(commonPath);
          log(`   Found at: ${commonPath}`, 'cyan');
          recordTest(`IDE Installation: ${ide} (custom path)`, 'PASS', `Found at ${commonPath}`);
          break;
        } catch (pathError) {
          // Path doesn't exist
        }
      }
    }
  }
}

// Test 7: Cross-platform compatibility
async function testCrossPlatformCompatibility() {
  log('\n=== Test 7: Cross-Platform Compatibility ===', 'blue');
  
  const platform = process.platform;
  const homeDir = os.homedir();
  
  log(`Platform: ${platform}`);
  log(`Home directory: ${homeDir}`);
  log(`Architecture: ${process.arch}`);
  
  // Test path generation for current platform
  const testPath = path.join(homeDir, 'DevXProjects', `${TEST_CONFIG.projectName}-${TEST_CONFIG.generationId}`);
  log(`Generated path: ${testPath}`);
  
  // Test path formatting for IDE URLs
  const isWindows = platform === 'win32';
  const formattedPath = isWindows ? testPath.replace(/\\/g, '/') : testPath;
  log(`Formatted path for IDE URL: ${formattedPath}`);
  
  // Test directory creation
  try {
    await fs.mkdir(testPath, { recursive: true });
    log(`✅ Can create project directory`, 'green');
    recordTest('Cross-Platform: Directory Creation', 'PASS', 'Directory creation works');
    
    // Clean up
    await fs.rmdir(testPath);
    log(`   Cleaned up test directory`, 'cyan');
  } catch (error) {
    log(`❌ Cannot create project directory: ${error.message}`, 'red');
    recordTest('Cross-Platform: Directory Creation', 'FAIL', `Directory creation failed: ${error.message}`, 'high');
  }
  
  // Test URL scheme registration (simulation)
  const vscodeUrl = `vscode://file/${formattedPath}`;
  const cursorUrl = `cursor://file/${formattedPath}`;
  
  log(`VSCode URL: ${vscodeUrl}`);
  log(`Cursor URL: ${cursorUrl}`);
  
  // Validate URL formats
  if (vscodeUrl.startsWith('vscode://file/') && !vscodeUrl.includes('undefined')) {
    log(`✅ VSCode URL format valid`, 'green');
    recordTest('Cross-Platform: VSCode URL', 'PASS', 'URL format valid');
  } else {
    log(`❌ VSCode URL format invalid`, 'red');
    recordTest('Cross-Platform: VSCode URL', 'FAIL', 'URL format invalid', 'medium');
  }
  
  if (cursorUrl.startsWith('cursor://file/') && !cursorUrl.includes('undefined')) {
    log(`✅ Cursor URL format valid`, 'green');
    recordTest('Cross-Platform: Cursor URL', 'PASS', 'URL format valid');
  } else {
    log(`❌ Cursor URL format invalid`, 'red');
    recordTest('Cross-Platform: Cursor URL', 'FAIL', 'URL format invalid', 'medium');
  }
}

// Test 8: Performance and load testing
async function testPerformance() {
  log('\n=== Test 8: Performance Testing ===', 'blue');
  
  const iterations = 5;
  const timings = [];
  
  log(`Running ${iterations} iterations of enhanced IDE launch...`);
  
  for (let i = 1; i <= iterations; i++) {
    const startTime = Date.now();
    
    try {
      const response = await fetch(`${TEST_CONFIG.baseUrl}/api/generate/ide-launch-enhanced`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          generationId: `${TEST_CONFIG.generationId}-perf-${i}`,
          ide: 'vscode',
          projectName: `${TEST_CONFIG.projectName}-perf-${i}`
        })
      });
      
      const endTime = Date.now();
      const duration = endTime - startTime;
      timings.push(duration);
      
      if (response.ok) {
        log(`   Iteration ${i}: ${duration}ms ✅`, 'green');
      } else {
        log(`   Iteration ${i}: ${duration}ms ❌ (${response.status})`, 'red');
      }
    } catch (error) {
      const endTime = Date.now();
      const duration = endTime - startTime;
      timings.push(duration);
      log(`   Iteration ${i}: ${duration}ms ❌ (${error.message})`, 'red');
    }
  }
  
  const avgTime = timings.reduce((a, b) => a + b, 0) / timings.length;
  const minTime = Math.min(...timings);
  const maxTime = Math.max(...timings);
  
  log(`\nPerformance Results:`);
  log(`   Average: ${avgTime.toFixed(2)}ms`);
  log(`   Min: ${minTime}ms`);
  log(`   Max: ${maxTime}ms`);
  
  if (avgTime < 2000) {
    log(`✅ Performance acceptable (< 2s average)`, 'green');
    recordTest('Performance: Response Time', 'PASS', `Average ${avgTime.toFixed(2)}ms`);
  } else if (avgTime < 5000) {
    log(`⚠️ Performance marginal (2-5s average)`, 'yellow');
    recordTest('Performance: Response Time', 'WARN', `Average ${avgTime.toFixed(2)}ms`);
  } else {
    log(`❌ Performance poor (>5s average)`, 'red');
    recordTest('Performance: Response Time', 'FAIL', `Average ${avgTime.toFixed(2)}ms`, 'medium');
  }
}

// Test 9: Security considerations
async function testSecurity() {
  log('\n=== Test 9: Security Testing ===', 'blue');
  
  const securityTests = [
    {
      name: 'Path traversal in project name',
      body: {
        generationId: TEST_CONFIG.generationId,
        ide: 'vscode',
        projectName: '../../../etc/passwd'
      }
    },
    {
      name: 'Path traversal in generation ID',
      body: {
        generationId: '../../../etc/passwd',
        ide: 'vscode',
        projectName: 'test'
      }
    },
    {
      name: 'Command injection in project name',
      body: {
        generationId: TEST_CONFIG.generationId,
        ide: 'vscode',
        projectName: 'test; rm -rf /'
      }
    },
    {
      name: 'XSS in project name',
      body: {
        generationId: TEST_CONFIG.generationId,
        ide: 'vscode',
        projectName: '<script>alert("xss")</script>'
      }
    }
  ];
  
  for (const test of securityTests) {
    log(`\nTesting: ${test.name}`);
    
    try {
      const response = await fetch(`${TEST_CONFIG.baseUrl}/api/generate/ide-launch-enhanced`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(test.body)
      });
      
      const result = await response.json();
      
      if (response.ok && result.localPath) {
        // Check if the path was properly sanitized
        const isUnsafe = result.localPath.includes('..') || 
                        result.localPath.includes('/etc/') ||
                        result.localPath.includes('rm -rf') ||
                        result.localPath.includes('<script>');
        
        if (isUnsafe) {
          log(`❌ ${test.name} - Security vulnerability detected!`, 'red');
          log(`   Unsafe path: ${result.localPath}`, 'red');
          recordTest(`Security: ${test.name}`, 'FAIL', 'Security vulnerability detected', 'critical');
        } else {
          log(`✅ ${test.name} - Input properly sanitized`, 'green');
          log(`   Safe path: ${result.localPath}`, 'cyan');
          recordTest(`Security: ${test.name}`, 'PASS', 'Input properly sanitized');
        }
      } else {
        log(`✅ ${test.name} - Request rejected (good)`, 'green');
        recordTest(`Security: ${test.name}`, 'PASS', 'Malicious request rejected');
      }
    } catch (error) {
      log(`⚠️ ${test.name} - Request failed: ${error.message}`, 'yellow');
      recordTest(`Security: ${test.name}`, 'WARN', `Request failed: ${error.message}`);
    }
  }
}

// Generate comprehensive test report
function generateTestReport() {
  log('\n=== COMPREHENSIVE TEST REPORT ===', 'magenta');
  log('=====================================', 'magenta');
  
  const total = testResults.passed + testResults.failed + testResults.warnings;
  const passRate = total > 0 ? ((testResults.passed / total) * 100).toFixed(1) : 0;
  
  log(`\nOverall Results:`);
  log(`✅ Passed: ${testResults.passed}`, 'green');
  log(`❌ Failed: ${testResults.failed}`, 'red');
  log(`⚠️ Warnings: ${testResults.warnings}`, 'yellow');
  log(`📊 Pass Rate: ${passRate}%`, passRate >= 90 ? 'green' : passRate >= 70 ? 'yellow' : 'red');
  
  // Categorize by severity
  const critical = testResults.tests.filter(t => t.severity === 'critical');
  const high = testResults.tests.filter(t => t.severity === 'high');
  const medium = testResults.tests.filter(t => t.severity === 'medium');
  
  if (critical.length > 0) {
    log(`\n🚨 CRITICAL ISSUES (${critical.length}):`, 'red');
    critical.forEach(test => {
      log(`   ${test.status} ${test.name}: ${test.message}`, 'red');
    });
  }
  
  if (high.length > 0) {
    log(`\n⚠️ HIGH PRIORITY ISSUES (${high.length}):`, 'yellow');
    high.forEach(test => {
      log(`   ${test.status} ${test.name}: ${test.message}`, 'yellow');
    });
  }
  
  if (medium.length > 0) {
    log(`\n📋 MEDIUM PRIORITY ISSUES (${medium.length}):`, 'cyan');
    medium.forEach(test => {
      log(`   ${test.status} ${test.name}: ${test.message}`, 'cyan');
    });
  }
  
  // Overall recommendation
  log(`\n🎯 RECOMMENDATION:`, 'magenta');
  if (critical.length > 0) {
    log(`❌ NOT READY FOR PRODUCTION - Critical issues must be fixed`, 'red');
  } else if (high.length > 0) {
    log(`⚠️ NEEDS FIXES - High priority issues should be addressed`, 'yellow');
  } else if (passRate >= 90) {
    log(`✅ READY FOR PRODUCTION - Excellent test results`, 'green');
  } else if (passRate >= 70) {
    log(`⚠️ MOSTLY READY - Minor issues to address`, 'yellow');
  } else {
    log(`❌ NEEDS WORK - Too many issues for production`, 'red');
  }
  
  return {
    summary: {
      total,
      passed: testResults.passed,
      failed: testResults.failed,
      warnings: testResults.warnings,
      passRate: parseFloat(passRate)
    },
    issues: {
      critical: critical.length,
      high: high.length,
      medium: medium.length
    },
    ready: critical.length === 0 && high.length === 0 && passRate >= 90
  };
}

// Main test runner
async function runComprehensiveTests() {
  log('🧪 COMPREHENSIVE IDE INTEGRATION TEST SUITE', 'magenta');
  log('===========================================', 'magenta');
  log(`Test started at: ${new Date().toISOString()}`, 'cyan');
  log(`Testing against: ${TEST_CONFIG.baseUrl}`, 'cyan');
  log(`Platform: ${process.platform} (${process.arch})`, 'cyan');
  
  try {
    // Run all test suites
    await testEndpointConnectivity();
    await testEnhancedIDELaunch();
    await testBasicIDELaunch();
    await testFileExtraction();
    await testErrorHandling();
    await testIDEInstallation();
    await testCrossPlatformCompatibility();
    await testPerformance();
    await testSecurity();
    
    // Generate final report
    const report = generateTestReport();
    
    // Return structured results for programmatic use
    return report;
    
  } catch (error) {
    log(`\n💥 Test suite failed: ${error.message}`, 'red');
    console.error(error);
    return {
      summary: { total: 0, passed: 0, failed: 1, warnings: 0, passRate: 0 },
      issues: { critical: 1, high: 0, medium: 0 },
      ready: false,
      error: error.message
    };
  }
}

// Check if running as a script or being imported
if (require.main === module) {
  runComprehensiveTests().then(report => {
    process.exit(report.ready ? 0 : 1);
  });
}

module.exports = { runComprehensiveTests, TEST_CONFIG };