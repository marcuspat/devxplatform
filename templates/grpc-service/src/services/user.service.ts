import * as grpc from '@grpc/grpc-js';
import { Timestamp } from 'google-protobuf/google/protobuf/timestamp_pb';
import { Empty } from 'google-protobuf/google/protobuf/empty_pb';
import { logger } from '../utils/logger';
import { validateInput } from '../utils/validation';

// Import generated proto types (these would be generated by the proto compiler)
import {
  User,
  GetUserRequest,
  ListUsersRequest,
  ListUsersResponse,
  CreateUserRequest,
  UpdateUserRequest,
  DeleteUserRequest,
  StreamUserUpdatesRequest,
  UserUpdate,
  BatchCreateUsersResponse,
  UserRole,
} from '../generated/user_pb';

// In-memory storage for demo (replace with database)
const users = new Map<string, User>();

export class UserServiceImplementation {
  async getUser(
    call: grpc.ServerUnaryCall<GetUserRequest, User>,
    callback: grpc.sendUnaryData<User>
  ) {
    try {
      const request = call.request;
      const userId = request.getId();

      logger.info(`Getting user with ID: ${userId}`);

      // Validate input
      if (!userId) {
        return callback({
          code: grpc.status.INVALID_ARGUMENT,
          message: 'User ID is required',
        });
      }

      // Find user
      const user = users.get(userId);
      if (!user) {
        return callback({
          code: grpc.status.NOT_FOUND,
          message: 'User not found',
        });
      }

      callback(null, user);
    } catch (error) {
      logger.error('Error in getUser:', error);
      callback({
        code: grpc.status.INTERNAL,
        message: 'Internal server error',
      });
    }
  }

  async listUsers(
    call: grpc.ServerUnaryCall<ListUsersRequest, ListUsersResponse>,
    callback: grpc.sendUnaryData<ListUsersResponse>
  ) {
    try {
      const request = call.request;
      const page = request.getPage() || 1;
      const pageSize = Math.min(request.getPageSize() || 10, 100);
      const _sortBy = request.getSortBy() || 'created_at';
      const _descending = request.getDescending();

      logger.info(`Listing users - page: ${page}, pageSize: ${pageSize}`);

      // Get all users
      const allUsers = Array.from(users.values());
      const total = allUsers.length;

      // Apply pagination
      const startIndex = (page - 1) * pageSize;
      const endIndex = startIndex + pageSize;
      const paginatedUsers = allUsers.slice(startIndex, endIndex);

      // Create response
      const response = new ListUsersResponse();
      response.setUsersList(paginatedUsers);
      response.setTotal(total);
      response.setPage(page);
      response.setPageSize(pageSize);
      response.setHasNext(endIndex < total);

      callback(null, response);
    } catch (error) {
      logger.error('Error in listUsers:', error);
      callback({
        code: grpc.status.INTERNAL,
        message: 'Internal server error',
      });
    }
  }

  async createUser(
    call: grpc.ServerUnaryCall<CreateUserRequest, User>,
    callback: grpc.sendUnaryData<User>
  ) {
    try {
      const request = call.request;
      
      // Validate input
      const validationError = validateInput(request, {
        email: { required: true, email: true },
        username: { required: true, minLength: 3, maxLength: 30 },
        firstName: { required: true, minLength: 1, maxLength: 50 },
        lastName: { required: true, minLength: 1, maxLength: 50 },
        password: { required: true, minLength: 8 },
      });

      if (validationError) {
        return callback({
          code: grpc.status.INVALID_ARGUMENT,
          message: validationError,
        });
      }

      // Check if user already exists
      const existingUser = Array.from(users.values()).find(
        u => u.getEmail() === request.getEmail() || u.getUsername() === request.getUsername()
      );

      if (existingUser) {
        return callback({
          code: grpc.status.ALREADY_EXISTS,
          message: 'User with this email or username already exists',
        });
      }

      // Create new user
      const user = new User();
      const userId = Date.now().toString();
      const now = new Date();
      const timestamp = new Timestamp();
      timestamp.fromDate(now);

      user.setId(userId);
      user.setEmail(request.getEmail());
      user.setUsername(request.getUsername());
      user.setFirstName(request.getFirstName());
      user.setLastName(request.getLastName());
      user.setRole(request.getRole() || UserRole.USER_ROLE_USER);
      user.setCreatedAt(timestamp);
      user.setUpdatedAt(timestamp);

      // Save user
      users.set(userId, user);

      logger.info(`Created user with ID: ${userId}`);
      callback(null, user);
    } catch (error) {
      logger.error('Error in createUser:', error);
      callback({
        code: grpc.status.INTERNAL,
        message: 'Internal server error',
      });
    }
  }

  async updateUser(
    call: grpc.ServerUnaryCall<UpdateUserRequest, User>,
    callback: grpc.sendUnaryData<User>
  ) {
    try {
      const request = call.request;
      const userId = request.getId();

      if (!userId) {
        return callback({
          code: grpc.status.INVALID_ARGUMENT,
          message: 'User ID is required',
        });
      }

      // Find user
      const user = users.get(userId);
      if (!user) {
        return callback({
          code: grpc.status.NOT_FOUND,
          message: 'User not found',
        });
      }

      // Update fields
      if (request.hasEmail()) {
        user.setEmail(request.getEmail()!);
      }
      if (request.hasUsername()) {
        user.setUsername(request.getUsername()!);
      }
      if (request.hasFirstName()) {
        user.setFirstName(request.getFirstName()!);
      }
      if (request.hasLastName()) {
        user.setLastName(request.getLastName()!);
      }
      if (request.hasRole()) {
        user.setRole(request.getRole()!);
      }

      // Update timestamp
      const timestamp = new Timestamp();
      timestamp.fromDate(new Date());
      user.setUpdatedAt(timestamp);

      logger.info(`Updated user with ID: ${userId}`);
      callback(null, user);
    } catch (error) {
      logger.error('Error in updateUser:', error);
      callback({
        code: grpc.status.INTERNAL,
        message: 'Internal server error',
      });
    }
  }

  async deleteUser(
    call: grpc.ServerUnaryCall<DeleteUserRequest, Empty>,
    callback: grpc.sendUnaryData<Empty>
  ) {
    try {
      const request = call.request;
      const userId = request.getId();

      if (!userId) {
        return callback({
          code: grpc.status.INVALID_ARGUMENT,
          message: 'User ID is required',
        });
      }

      // Check if user exists
      if (!users.has(userId)) {
        return callback({
          code: grpc.status.NOT_FOUND,
          message: 'User not found',
        });
      }

      // Delete user
      users.delete(userId);

      logger.info(`Deleted user with ID: ${userId}`);
      callback(null, new Empty());
    } catch (error) {
      logger.error('Error in deleteUser:', error);
      callback({
        code: grpc.status.INTERNAL,
        message: 'Internal server error',
      });
    }
  }

  async streamUserUpdates(
    call: grpc.ServerWritableStream<StreamUserUpdatesRequest, UserUpdate>
  ) {
    try {
      const request = call.request;
      const userIds = request.getUserIdsList();
      const _includeAll = request.getIncludeAll();

      logger.info(`Streaming user updates for ${userIds.length} users`);

      // In a real implementation, you would:
      // 1. Subscribe to user update events
      // 2. Filter events based on user IDs
      // 3. Stream updates to the client

      // For demo, send a test update
      const userUpdate = new UserUpdate();
      userUpdate.setType(UserUpdate.UpdateType.UPDATE_TYPE_CREATED);
      
      const timestamp = new Timestamp();
      timestamp.fromDate(new Date());
      userUpdate.setTimestamp(timestamp);

      call.write(userUpdate);

      // Keep connection alive
      const interval = setInterval(() => {
        // Send heartbeat or check for new updates
      }, 30000);

      call.on('cancelled', () => {
        clearInterval(interval);
        logger.info('Stream cancelled by client');
      });

      call.on('end', () => {
        clearInterval(interval);
        logger.info('Stream ended');
      });
    } catch (error) {
      logger.error('Error in streamUserUpdates:', error);
      call.destroy();
    }
  }

  async batchCreateUsers(
    call: grpc.ServerReadableStream<CreateUserRequest, BatchCreateUsersResponse>,
    callback: grpc.sendUnaryData<BatchCreateUsersResponse>
  ) {
    try {
      const createdUsers: User[] = [];
      const errors: string[] = [];
      let successCount = 0;
      let failureCount = 0;

      call.on('data', (request: CreateUserRequest) => {
        try {
          // Validate and create user (simplified)
          const user = new User();
          const userId = Date.now().toString();
          const now = new Date();
          const timestamp = new Timestamp();
          timestamp.fromDate(now);

          user.setId(userId);
          user.setEmail(request.getEmail());
          user.setUsername(request.getUsername());
          user.setFirstName(request.getFirstName());
          user.setLastName(request.getLastName());
          user.setRole(request.getRole() || UserRole.USER_ROLE_USER);
          user.setCreatedAt(timestamp);
          user.setUpdatedAt(timestamp);

          users.set(userId, user);
          createdUsers.push(user);
          successCount++;
        } catch (error) {
          failureCount++;
          errors.push(`Failed to create user: ${error}`);
        }
      });

      call.on('end', () => {
        const response = new BatchCreateUsersResponse();
        response.setUsersList(createdUsers);
        response.setSuccessCount(successCount);
        response.setFailureCount(failureCount);
        response.setErrorsList(errors);

        logger.info(`Batch created ${successCount} users, ${failureCount} failures`);
        callback(null, response);
      });

      call.on('error', (error) => {
        logger.error('Error in batchCreateUsers:', error);
        callback({
          code: grpc.status.INTERNAL,
          message: 'Internal server error',
        });
      });
    } catch (error) {
      logger.error('Error in batchCreateUsers:', error);
      callback({
        code: grpc.status.INTERNAL,
        message: 'Internal server error',
      });
    }
  }
}